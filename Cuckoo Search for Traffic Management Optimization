#Application:Optimization of Traffic Management
import random
import math

# ---------------- Traffic Simulation Function ---------------- #

def simulate_traffic(green_times):
    """
    green_times: [g1, g2, g3, g4] green time for each of 4 directions
    returns total waiting time (to be minimized)
    """

    # average traffic arrival rate (vehicles/sec) for each direction
    arrival = [0.8, 1.1, 0.6, 0.9]  # adjust as required

    total_waiting = 0

    for arr, green in zip(arrival, green_times):
        # vehicles arriving during a cycle
        vehicles = arr * cycle_time

        # vehicles that can pass (assume 1 vehicle/second during green)
        passed = green

        # queue leftover -> waiting contribution
        waiting = max(0, vehicles - passed)

        # weighted wait time approximation
        total_waiting += waiting**2  

    return total_waiting

# ---------------- Cuckoo Search Optimization ---------------- #

def levy_flight(Lambda=1.5):
    u = random.random() * 0.1
    v = random.random()
    step = u / (abs(v) ** (1 / Lambda))
    return step

def cuckoo_search(n=10, pa=0.25, iterations=50):
    # initial nests (green times for 4 signals)
    nests = [[random.uniform(10, 60) for _ in range(4)] for _ in range(n)]

    fitness = [simulate_traffic(nest) for nest in nests]

    global_best = nests[fitness.index(min(fitness))]
    global_best_fit = min(fitness)

    for it in range(iterations):

        # Generate new solutions by Levy flights
        for i in range(n):
            new = []
            for x in nests[i]:
                step = levy_flight()
                new_val = x + step * (x - global_best[0])
                new.append(max(5, min(90, new_val)))  # bounds
            new_fit = simulate_traffic(new)

            if new_fit < fitness[i]:
                nests[i], fitness[i] = new, new_fit

                if new_fit < global_best_fit:
                    global_best = new
                    global_best_fit = new_fit

        # Abandon some worst nests
        for i in range(n):
            if random.random() < pa:
                nests[i] = [random.uniform(10, 60) for _ in range(4)]
                fitness[i] = simulate_traffic(nests[i])

        print(f"Iteration {it+1} | Best waiting time = {global_best_fit:.4f}")

    return global_best, global_best_fit

# ---------------- Execution ---------------- #

cycle_time = 120  # total cycle length in seconds (modifiable)

best_solution, best_wait = cuckoo_search()

print("\nOptimal Green Signal Timings (seconds):")
print(f"North-South Straight   : {best_solution[0]:.2f}")
print(f"North-South Right Turn : {best_solution[1]:.2f}")
print(f"East-West Straight     : {best_solution[2]:.2f}")
print(f"East-West Right Turn   : {best_solution[3]:.2f}")

print(f"\nMinimum Estimated Waiting Time: {best_wait:.4f}")
